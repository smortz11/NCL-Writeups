# Web App Vulnerability Walkthrough
In this room, we are given a deprecated web UI and are told to drain the other user's account. 

---
# Q1 - 10 Points
#### What is the path of the leaked file?

Let's begin with some of our manual reconnaissance. I started by checking the page source (RMB -> View Page Source). Here, we are given the HTML of the site, which we can begin to scrutinize for vulnerabilities.

In the provided HTML, one thing looked interesting to me, this line:
`<script src="/static/app.js"></script>`. Maybe something is wrong with the javascript? We can navigate to this file by appending `/static/app.js`

Output:

```javascript
function transfer() {
  var amount = $('#transferAmnt').val();
  superagent.post('/transfer')
    .send({
      amount,
      account : 'ForgeOfNeverWinter',
    })
    .then(function () {
      location.reload();
    }).catch(console.error)
  ;
}

function reset() {
  superagent.get('/reset').then(function() {
    location.reload();
  }).catch(console.error);
}
```

Here, the account field caught my eye. It appears that the account name is hard coded, however in the rules, we are told we can not brute force the site (ie try every account). This stumped me. I used a hint.

Apparently the answer is in `/robots.txt`. This contains a list of paths that *cannot* be accessed automatically via robots. I guess we add checking this to every flow chart now.

In /robots.txt, we see a file that is likely the leaked path.
#### Answer:
`/dev/rel.js`

---
# Q2 - 90 Points
#### What is the flag?

Let's try to navigate to that prior path. It works and we can see this output:
```javascript
// TODO auditor says something is wrong with this code....
if (parseInt(amount) < account.amount) {
  if ((account.amount - parseInt(amount)) < account.minimum) {
    return res.status(400).send('Error: Account is not allowed to have a balance lower than 10');
  }
  var transferAmount = parseInt(amount, 10);
  account.amount -= transferAmount;
}
```

Let's try to understand this.
1. parseInt(amount) -> The value we input
2. account.amount -> The amount in the account
3. account.minimum -> 10 (Assumed from error status)

Following the flow of the program, we get nowhere if we don't enter the first if statement. However, if we enter the second if statement, we return and see no obvious vulnerabilities.

So, let's say we transfer an amount that is legal, ie, leaves more than 10 in our account. We then access the following lines of code:

```javascript
var transferAmount = parseInt(amount, 10);
account.amount -= transferAmount;
```

Notice anything different? The second line looks fine, subtract the transfer amount from our account. This time, however, `parseInt` has two parameters. Let's look it up and check it out [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt).

```
An integer between `2` and `36` that represents the _radix_ (the base in mathematical numeral systems) of the `string`. It is converted to a [32-bit integer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#fixed-width_number_conversion); if it's nonzero and outside the range of [2, 36] after conversion, the function will always return `NaN`. If `0` or not provided, the radix will be inferred based on `string`'s value. Be careful â€” this does _not_ always default to `10`! The [description below](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt#description) explains in more detail what happens when `radix` is not provided.
```

So, essentially, we are converting our transfer amount to base 10 before we do the transfer. this should already be done.

Apparently, there are a few issues. We can submit negative numbers. This, however, doesn't give us anything.

When `parseInt` has no radix specified, though, a leading zero indicates octal. It's kinda like a nerfed hexadecimal format.

So now, we are looking for an octal value that is less than 1000, but when treated as a base 10 number, is more. I used [this](https://www.binaryhexconverter.com/decimal-to-octal-converter) site to convert decimal 1000 to octal (happens to be 1750)

When we submit 01750, though, it does not work (we must submit an octal that is LESS than our account amount). Submitting 01749 gives us the flag.
#### Answer:
`SKY-BJHO-1719`

---
# Conclusion

For me, web app exploitation is a weak point. It is difficult for me. I will be compiling a list of tactics and techniques to try out when I am done with this module. Hopefully this will help!